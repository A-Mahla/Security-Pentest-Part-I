# level14 - Reverse engineering using GDB

## Summary

When we arrived at this level14, nothing is given to us to see even have after
spending a long time to enumerate… So the last thing to do is to disass command
`getflag` itself. let’s do it !

<br>

After some invetigate we find two section very interresting in `main` function…

```shell
~$ gdb -q getflag
Reading symbols from /bin/getflag...(no debugging symbols found)...done.
(gdb) disass main
Dump of assembler code for function main:
   0x08048946 <+0>:	push   %ebp
   0x08048947 <+1>:	mov    %esp,%ebp
   ...
   0x08048989 <+67>:	call   0x8048540 <ptrace@plt>
   0x0804898e <+72>:	test   %eax,%eax
   0x08048990 <+74>:	jns    0x80489a8 <main+98>
   ...
   0x08048afd <+439>:	call   0x80484b0 <getuid@plt>
   0x08048b02 <+444>:	mov    %eax,0x18(%esp)
   0x08048b06 <+448>:	mov    0x18(%esp),%eax
   0x08048b0a <+452>:	cmp    $0xbbe,%eax
   0x08048b0f <+457>:	je     0x8048ccb <main+901>
   0x08048b15 <+463>:	cmp    $0xbbe,%eax
   0x08048b1a <+468>:	ja     0x8048b68 <main+546>
   0x08048b1c <+470>:	cmp    $0xbba,%eax
   0x08048b21 <+475>:	je     0x8048c3b <main+757>
   0x08048b27 <+481>:	cmp    $0xbba,%eax
   0x08048b2c <+486>:	ja     0x8048b4d <main+519>
   0x08048b2e <+488>:	cmp    $0xbb8,%eax
   0x08048b33 <+493>:	je     0x8048bf3 <main+685>
   0x08048b39 <+499>:	cmp    $0xbb8,%eax
   0x08048b3e <+504>:	ja     0x8048c17 <main+721>
   0x08048b44 <+510>:	test   %eax,%eax
   0x08048b46 <+512>:	je     0x8048bc6 <main+640>
   0x08048b48 <+514>:	jmp    0x8048e06 <main+1216>
   0x08048b4d <+519>:	cmp    $0xbbc,%eax
   0x08048b52 <+524>:	je     0x8048c83 <main+829>
   0x08048b58 <+530>:	cmp    $0xbbc,%eax
   0x08048b5d <+535>:	ja     0x8048ca7 <main+865>
   0x08048b63 <+541>:	jmp    0x8048c5f <main+793>
   0x08048b68 <+546>:	cmp    $0xbc2,%eax
   0x08048b6d <+551>:	je     0x8048d5b <main+1045>
   0x08048b73 <+557>:	cmp    $0xbc2,%eax
   0x08048b78 <+562>:	ja     0x8048b95 <main+591>
   0x08048b7a <+564>:	cmp    $0xbc0,%eax
   0x08048b7f <+569>:	je     0x8048d13 <main+973>
   0x08048b85 <+575>:	cmp    $0xbc0,%eax
   0x08048b8a <+580>:	ja     0x8048d37 <main+1009>
   0x08048b90 <+586>:	jmp    0x8048cef <main+937>
   0x08048b95 <+591>:	cmp    $0xbc4,%eax
   0x08048b9a <+596>:	je     0x8048da3 <main+1117>
   0x08048ba0 <+602>:	cmp    $0xbc4,%eax
   0x08048ba5 <+607>:	jb     0x8048d7f <main+1081>
   0x08048bab <+613>:	cmp    $0xbc5,%eax
   0x08048bb0 <+618>:	je     0x8048dc4 <main+1150>
   0x08048bb6 <+624>:	cmp    $0xbc6,%eax
   0x08048bbb <+629>:	je     0x8048de5 <main+1183>
   ...
```
Indeed, On the first section, after the return of `ptrace()`, the register `eax`
is test to know if we are reversing the binary. it’s the protection to
bypass if we want to access to the second section. This section is just a 
check to now who we are using `getuid()` function. If our `uid` is one of the
flag group (flag00, flag01, … , flag14), we can access to the corresponding 
token. As we can see, each `cmp` instruction is just match a flag’s uid, for 
example: `cmp $0xbbc,%eax` → **0xbbc** = **3004** = **flag04’s uid**.

<br>

## Exploit

So, as we can see on the disassembly of `main` function, if the return (`eax`)
of the function `ptrace()` is negative, the execution will exit before being
able to exploit the vulnerability.

```shell
~$ gdb -q getflag
Reading symbols from /bin/getflag...(no debugging symbols found)...done.
(gdb) r
tarting program: /bin/getflag 
You should not reverse this
[Inferior 1 (process 3416) exited with code 01]
```

<br>

Knowing this, when we get to the `test %eax,%eax` instruction we can change
the value of `eax` to **0x0**, and then, the next instruction `jns 0x80489a8 <main+98>` will trigger the jump to `<main+98>`, and therefore exit from the
program.

```shell
((gdb) b *0x0804898e
Breakpoint 1 at 0x804898e
(gdb) r
Starting program: /bin/getflag 

Breakpoint 1, 0x0804898e in main ()
(gdb) p/x $eax
$1 = 0xffffffff
(gdb) set $eax=0
(gdb) p/x $eax
$2 = 0x0
```

<br>

Now we did it, we can continue the execution of the program… But we have to
break to the instruction just next to the `getuid()` function call and modifie
the return of this function to set the **uid** we want ! The only regret I 
have is that this flaw was available from level00 *but better late than never
at all*.

```shell
gdb) b *0x08048b0a
Breakpoint 2 at 0x8048b0a
(gdb) c
Continuing.

Breakpoint 2, 0x08048b0a in main ()
(gdb) p/d $eax
$3 = 2014
(gdb) set $eax=3014
(gdb) p/d $eax
$4 = 3014
(gdb) c
Continuing.
Check flag.Here is your token : 7QiHafiNa3HVozsaXkawuYrTstxbpABHD8CPnHJ
[Inferior 1 (process 3492) exited normally]
```
> This the last exploit, we can log on flag14 user with it.
