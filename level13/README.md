# level13 - Reverse engineering using GDB

## Summary

First of all, we look at `HOME` directory and we find the binary `level13`.

<br>

When we try to run it, a string tells us that our uid is 2013 and 
that the **uid** expected by the binary is 4242. Try to de-compile it…

```shell
~$ ls -l

-rwsr-sr-x 1 flag13  level13 7303 Aug 30  2015 level13


~$ ./level13

UID 2013 started us but we expect 4242
```

The problem is that we can't inject command because we don't have any input
and we can't change our **uid** or create user with the correct **uid** because
we are not root… and after some investigation of a possible shared libraries or
object exploit, we don’t figure out a usable vulnerability. So the only way we
have is to change the execution of the binary itself. 

<br>

```shell

~$ strings level13

...
UID %d started us but we we expect %d
boe]!ai0FB@.:|L6l@A?>qJ}I
your token is %s
...
```
As we can see the token is encrypted. We now know enough, so let's use GDB to exploit it !

<br>

## Exploit

As we see above, let’s disass main function using GDB.

```shell
~$ gdb -q level13

Reading symbols from /home/user/level13/level13...(no debugging symbols found)...done.
(gdb) info func
All defined functions:

Non-debugging symbols:
0x08048314  _init
...
0x0804858c  main
...
(gdb) disass main
	 0x0804858c <+0>:	push   %ebp
   0x0804858d <+1>:	mov    %esp,%ebp
   ...
   0x08048595 <+9>:	call   0x8048380 <getuid@plt>
   0x0804859a <+14>:	cmp    $0x1092,%eax
   0x0804859f <+19>:	je     0x80485cb <main+63>
   ...
   0x080485c6 <+58>:	call   0x80483a0 <exit@plt>
   0x080485cb <+63>:	movl   $0x80486ef,(%esp)
   0x080485d2 <+70>:	call   0x8048474 <ft_des>
   0x080485d7 <+75>:	mov    $0x8048709,%edx
   0x080485dc <+80>:	mov    %eax,0x4(%esp)
   0x080485e0 <+84>:	mov    %edx,(%esp)
   0x080485e3 <+87>:	call   0x8048360 <printf@plt>
   0x080485e8 <+92>:	leave  
   0x080485e9 <+93>:	ret
```
We can see know that if the return (`eax`) of the function `getuid()` is not 
**0x1092** (i.e. 42), the execution will exit (<main+58>) without display the
token. In otherhand, the execution jump to `<main+63>` to continue the 
execution and display the token !

<br>

Knowing this, when we get to the `cmp $0x1092,%eax` instruction we can change the value of `eax` to **0x1092** and then jump to the `<main+63>` instruction, and so, display our token.

```shell
(gdb) b *0x0804859a
Breakpoint 1 at 0x804859a
(gdb) r
Starting program: /home/user/level13/level13 

Breakpoint 1, 0x0804859a in main ()
(gdb) p/d $eax
$1 = 2013
(gdb) set $eax=0x1092
(gdb) p/d $eax
$2 = 4242
(gdb) c
Continuing.
your token is 2A31L79asukciNyi8uppkEuSx
[Inferior 1 (process 2222) exited with code 050]
(gdb)
```
